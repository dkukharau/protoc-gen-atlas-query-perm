package plugin

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"

	"github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
)

const (
	filtering                     = ".infoblox.api.Filtering"
	sorting                       = ".infoblox.api.Sorting"
	messagesValidationVarSuffix   = "MessagesRequireQueryValidation"
	methodFilteringVarSuffix      = "MethodsRequireFilteringValidation"
	methodSortingVarSuffix        = "MethodsRequireSortingValidation"
	validateFilteringMethodSuffix = "ValidateFiltering"
	validateSortingMethodSuffix   = "ValidateSorting"

	protoTypeTimestamp   = ".google.protobuf.Timestamp"
	protoTypeUUID        = ".gorm.types.UUID"
	protoTypeUUIDValue   = ".gorm.types.UUIDValue"
	protoTypeResource    = ".atlas.rpc.Identifier"
	protoTypeInet        = ".gorm.types.InetValue"
	protoTypeStringValue = ".google.protobuf.StringValue"
	protoTypeDoubleValue = ".google.protobuf.DoubleValue"
	protoTypeFloatValue  = ".google.protobuf.FloatValue"
	protoTypeInt32Value  = ".google.protobuf.Int32Value"
	protoTypeInt64Value  = ".google.protobuf.Int64Value"
	protoTypeUInt32Value = ".google.protobuf.UInt32Value"
	protoTypeUInt64Value = ".google.protobuf.UInt64Value"
)

// QueryValidatePlugin implements the plugin interface and creates validations for collection operation parameters code from .protos
type QueryValidatePlugin struct {
	*generator.Generator
	currentFile                        *generator.FileDescriptor
	messagesValidationVarName          string
	requiredFilteringValidationVarName string
	requiredSortingValidationVarName   string
	validateFilteringMethodName        string
	validateSortingMethodName          string
}

func (p *QueryValidatePlugin) setFile(file *generator.FileDescriptor) {
	p.currentFile = file
	// p.Generator.SetFile(file.FileDescriptorProto)

	baseFileName := filepath.Base(file.GetName())
	p.messagesValidationVarName = generator.CamelCase(strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + messagesValidationVarSuffix)
	p.requiredFilteringValidationVarName = generator.CamelCase(strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + methodFilteringVarSuffix)
	p.requiredSortingValidationVarName = generator.CamelCase(strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + methodSortingVarSuffix)
	p.validateFilteringMethodName = generator.CamelCase(strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + validateFilteringMethodSuffix)
	p.validateSortingMethodName = generator.CamelCase(strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + validateSortingMethodSuffix)
}

// Name identifies the plugin
func (p *QueryValidatePlugin) Name() string {
	return "atlas-query-validate"
}

// Init is called once after data structures are built but before
// code generation begins.
func (p *QueryValidatePlugin) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *QueryValidatePlugin) Generate(file *generator.FileDescriptor) {
	p.setFile(file)
	p.genValidationData()
	p.genValidateFiltering()
	p.genValidateSorting()
}

func (p *QueryValidatePlugin) genValidationData() {
	msgByName := map[string]*generator.Descriptor{}
	msgWithFilteringField := map[string]struct{}{}
	msgWithSortingField := map[string]struct{}{}

	packageName := p.currentFile.Package

	// generate message validation data
	p.P(`var `, p.messagesValidationVarName, ` = map[string]map[string]options.FilteringOption{`)
	for _, msg := range p.currentFile.Messages() {
		fullMsgName := fmt.Sprintf(".%s.%s", *packageName, generator.CamelCaseSlice(msg.TypeName()))
		msgByName[fullMsgName] = msg
		p.generateMessageValidationInfo(msg)

		hasFiltering, hasSorting := p.checkCollectionOperators(msg)
		if hasFiltering {
			msgWithFilteringField[fullMsgName] = struct{}{}
		}
		if hasSorting {
			msgWithSortingField[fullMsgName] = struct{}{}
		}
	}
	p.P(`}`)

	data := []struct {
		varName string
		msgs    map[string]struct{}
	}{
		{p.requiredFilteringValidationVarName, msgWithFilteringField},
		{p.requiredSortingValidationVarName, msgWithSortingField},
	}

	for _, v := range data {
		prefix := v.varName
		reqValidation := v.msgs
		// generate methods required validation data
		p.P(`var `, prefix, ` = map[string]string{`)
		for _, srv := range p.currentFile.GetService() {
			for _, method := range srv.GetMethod() {

				_, hasFilteringSorting := reqValidation[method.GetInputType()]
				msg, ok := msgByName[method.GetOutputType()]
				if !ok {
					continue
				}
				msgFieldType := p.hasRequiredValidationField(msg, msgByName)
				if hasFilteringSorting && len(msgFieldType) > 0 {
					p.P(`"`, fmt.Sprintf("/%s.%s/%s", *packageName, srv.GetName(), method.GetName()), `": "`, strings.TrimLeft(msgFieldType, "."+*packageName), `",`)
				}
			}
		}
		p.P(`}`)
	}

}

func (p *QueryValidatePlugin) hasRequiredValidationField(msg *generator.Descriptor, allMsgs map[string]*generator.Descriptor) string {
	for _, msgField := range msg.GetField() {
		if _, ok := allMsgs[msgField.GetTypeName()]; ok {
			return msgField.GetTypeName()
		}
	}
	return ""
}

func (p *QueryValidatePlugin) checkCollectionOperators(msg *generator.Descriptor) (bool, bool) {
	var hasFilteringField, hasSortingField bool
	for _, msgField := range msg.GetField() {
		if msgField.GetTypeName() == filtering {
			hasFilteringField = true
		}
		if msgField.GetTypeName() == sorting {
			hasSortingField = true
		}
	}
	return hasFilteringField, hasSortingField
}

func (p *QueryValidatePlugin) generateMessageValidationInfo(msg *generator.Descriptor) {
	msgTypeName := generator.CamelCaseSlice(msg.TypeName())
	p.P(`"`, msgTypeName, `": {`)
	for _, v := range p.getValidationData(msg) {
		if v.option.FilterType == options.QueryValidate_DEFAULT {
			continue
		}
		var s string
		if v.option.DisableSorting {
			s = `DisableSorting: true,`
		}
		var f string
		if len(v.option.Deny) != 0 {
			for _, d := range v.option.Deny {
				f += "options.QueryValidate_" + d.String() + `,`
			}
			f = `Deny: []options.QueryValidate_FilterOperator{` + f + `},`
		}
		t := `FilterType: options.QueryValidate_` + v.option.FilterType.String()
		p.P(`"`, v.fieldName, `": options.FilteringOption{`+s+f+t+`},`)
	}
	p.P(`},`)
}

type fieldValidate struct {
	fieldName string
	option    options.FilteringOption
}

// getValidationData - returns list of validation data per field
func (p *QueryValidatePlugin) getValidationData(msg *generator.Descriptor) []fieldValidate {
	var data []fieldValidate
	for _, field := range msg.GetField() {
		opts := getQueryValidationOptions(field)
		fieldName := field.GetName()
		filterType := opts.GetFilterType()
		disableSorting := opts.GetDisableSorting()
		if filterType == options.QueryValidate_DEFAULT {
			if field.IsRepeated() {
				continue
			}
			switch field.GetType() {
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				filterType = options.QueryValidate_STRING
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				filterType = options.QueryValidate_STRING
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
				descriptor.FieldDescriptorProto_TYPE_FLOAT,
				descriptor.FieldDescriptorProto_TYPE_INT32,
				descriptor.FieldDescriptorProto_TYPE_INT64,
				descriptor.FieldDescriptorProto_TYPE_SINT32,
				descriptor.FieldDescriptorProto_TYPE_SINT64,
				descriptor.FieldDescriptorProto_TYPE_UINT32,
				descriptor.FieldDescriptorProto_TYPE_UINT64:
				filterType = options.QueryValidate_NUMBER
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				switch field.GetTypeName() {
				case protoTypeResource,
					protoTypeTimestamp,
					protoTypeUUID,
					protoTypeUUIDValue,
					protoTypeInet,
					protoTypeStringValue:
					filterType = options.QueryValidate_STRING
				case protoTypeDoubleValue,
					protoTypeFloatValue,
					protoTypeInt32Value,
					protoTypeInt64Value,
					protoTypeUInt32Value,
					protoTypeUInt64Value:
					filterType = options.QueryValidate_NUMBER
				default:
					if opts.GetEnableNestedFields() {
						nestedMsg := p.ObjectNamed(field.GetTypeName()).(*generator.Descriptor)
						nestedDeny := p.getValidationData(nestedMsg)
						for _, v := range nestedDeny {
							data = append(data, fieldValidate{fieldName + "." + v.fieldName, v.option})
						}
						continue
					}

				}
			default:
				continue
			}
		}
		data = append(data, fieldValidate{fieldName, options.FilteringOption{FilterType: filterType, DisableSorting: disableSorting, Deny: p.getDenyRules(field, filterType)}})
	}
	return data
}

func (p *QueryValidatePlugin) getDenyRules(field *descriptor.FieldDescriptorProto, filterType options.QueryValidate_FilterType) []options.QueryValidate_FilterOperator {
	opts := getQueryValidationOptions(field)
	fieldName := field.GetName()
	opsAllowed := opts.GetAllow()
	opsDenied := opts.GetDeny()

	if len(opsAllowed) > 0 && len(opsDenied) > 0 {
		p.Fail(fieldName, ": both allow and deny options are not allowed")
	}

	if len(opsAllowed) == 0 && len(opsDenied) == 0 {
		return nil
	}

	var supportedOps []options.QueryValidate_FilterOperator
	if filterType == options.QueryValidate_NUMBER {
		supportedOps = []options.QueryValidate_FilterOperator{
			options.QueryValidate_EQ,
			options.QueryValidate_GT,
			options.QueryValidate_GE,
			options.QueryValidate_LT,
			options.QueryValidate_LE,
		}
	} else if filterType == options.QueryValidate_STRING {
		supportedOps = []options.QueryValidate_FilterOperator{
			options.QueryValidate_EQ,
			options.QueryValidate_MATCH,
			options.QueryValidate_GT,
			options.QueryValidate_GE,
			options.QueryValidate_LT,
			options.QueryValidate_LE,
		}
	}

	ops := opsAllowed
	if len(opsDenied) > 0 {
		ops = opsDenied
	}

	for _, item := range ops {
		var found bool
		for _, i := range supportedOps {
			if item == i {
				found = true
				break
			}
		}
		if !found && item != options.QueryValidate_ALL {
			p.Fail(fmt.Sprintf("'%s'filtering operator is not supported for fieldValidate '%s'", item, fieldName))
		}
	}

	var res []options.QueryValidate_FilterOperator
	if len(opsAllowed) > 0 {
	OUTER:
		for _, op := range supportedOps {
			found := false
			for _, allowedOp := range ops {
				if allowedOp == options.QueryValidate_ALL {
					res = nil
					break OUTER
				}
				if op == allowedOp {
					found = true
					break
				}
			}
			if !found {
				res = append(res, op)
			}
		}
	} else {
		res = ops
		for _, op := range ops {
			if op == options.QueryValidate_ALL {
				res = []options.QueryValidate_FilterOperator{options.QueryValidate_ALL}
				break
			}
		}
	}
	return res
}

func (p *QueryValidatePlugin) genValidateFiltering() {
	p.P(`func `, p.validateFilteringMethodName, `(methodName string, f *query.Filtering) error {`)
	p.P(`objName, ok := `, p.requiredFilteringValidationVarName, `[methodName]`)
	p.P(`if !ok {`)
	p.P(`return nil`)
	p.P(`}`)
	p.P(`var info map[string]options.FilteringOption`)
	p.P(`info, ok = `, p.messagesValidationVarName, `[objName]`)
	p.P(`if !ok {`)
	p.P(`return nil`)
	p.P(`}`)
	p.P(`return options.ValidateFiltering(f, info)`)
	p.P(`}`)
}

func (p *QueryValidatePlugin) genValidateSorting() {
	p.P(`func `, p.validateSortingMethodName, `(methodName string, s *query.Sorting) error {`)
	p.P(`objName, ok := `, p.requiredSortingValidationVarName, `[methodName]`)
	p.P(`if !ok {`)
	p.P(`return nil`)
	p.P(`}`)
	p.P(`var info map[string]options.FilteringOption`)
	p.P(`info, ok = `, p.messagesValidationVarName, `[objName]`)
	p.P(`if !ok {`)
	p.P(`return nil`)
	p.P(`}`)
	p.P(`return options.ValidateSorting(s, info)`)
	p.P(`}`)
}

func getQueryValidationOptions(field *descriptor.FieldDescriptorProto) *options.QueryValidate {
	if field.Options == nil {
		return nil
	}
	v, err := proto.GetExtension(field.Options, options.E_Validate)
	if err != nil {
		return nil
	}
	opts, ok := v.(*options.QueryValidate)
	if !ok {
		return nil
	}
	return opts
}

func (p *QueryValidatePlugin) CleanFiles(response *plugin.CodeGeneratorResponse) {
	for i := 0; i < len(response.File); i++ {
		file := response.File[i]
		file.Content = CleanImports(file.Content)
	}
}
